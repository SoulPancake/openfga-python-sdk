"""
Python SDK for OpenFGA

API version: 1.x
Website: https://openfga.dev
Documentation: https://openfga.dev/docs
Support: https://openfga.dev/community
License: [Apache-2.0](https://github.com/openfga/python-sdk/blob/main/LICENSE)

NOTE: This file was auto generated by OpenAPI Generator (https://openapi-generator.tech). DO NOT EDIT.
"""

# Specific FGA header to be parsed
X_RATELIMIT_LIMIT = "x-ratelimit-limit"
X_RATELIMIT_REMAINING = "x_ratelimit_remaining"
X_RATELIMIT_RESET = "x_ratelimit_reset"
FGA_REQUEST_ID = "fga-request-id"
FGA_QUERY_DURATION_MS = "fga-query-duration-ms"
OPENFGA_AUTHORIZATION_MODEL_ID = "openfga_authorization_model_id"
RETRY_AFTER = "retry-after"
RESPONSE_HEADERS_TO_KEEP = [
    X_RATELIMIT_LIMIT,
    X_RATELIMIT_REMAINING,
    X_RATELIMIT_RESET,
    FGA_REQUEST_ID,
    FGA_QUERY_DURATION_MS,
    OPENFGA_AUTHORIZATION_MODEL_ID,
    RETRY_AFTER,
]


class OpenApiException(Exception):
    """The base exception class for all OpenAPIExceptions"""


class FgaValidationException(OpenApiException, TypeError):
    def __init__(self, msg, path_to_item=None, valid_classes=None, key_type=None):
        """Raises an exception for TypeErrors

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list): a list of keys an indices to get to the
                                 current_item
                                 None if unset
            valid_classes (tuple): the primitive classes that current item
                                   should be an instance of
                                   None if unset
            key_type (bool): False if our value is a value in a dict
                             True if it is a key in a dict
                             False if our item is an item in a list
                             None if unset
        """
        self.path_to_item = path_to_item
        self.valid_classes = valid_classes
        self.key_type = key_type
        full_msg = msg
        if path_to_item:
            full_msg = f"{msg} at {render_path(path_to_item)}"
        super().__init__(full_msg)


class ApiValueError(OpenApiException, ValueError):
    def __init__(self, msg, path_to_item=None):
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (list) the path to the exception in the
                received_data dict. None if unset
        """

        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = f"{msg} at {render_path(path_to_item)}"
        super().__init__(full_msg)


class ApiAttributeError(OpenApiException, AttributeError):
    def __init__(self, msg, path_to_item=None):
        """
        Raised when an attribute reference or assignment fails.

        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = f"{msg} at {render_path(path_to_item)}"
        super().__init__(full_msg)


class ApiKeyError(OpenApiException, KeyError):
    def __init__(self, msg, path_to_item=None):
        """
        Args:
            msg (str): the exception message

        Keyword Args:
            path_to_item (None/list) the path to the exception in the
                received_data dict
        """
        self.path_to_item = path_to_item
        full_msg = msg
        if path_to_item:
            full_msg = f"{msg} at {render_path(path_to_item)}"
        super().__init__(full_msg)


class ApiException(OpenApiException):
    def __init__(self, status=None, reason=None, http_resp=None, operation_name=None):
        if http_resp:
            try:
                headers = http_resp.headers.items()
            except AttributeError:
                headers = http_resp.getheaders().items()

            self.status = http_resp.status
            self.reason = http_resp.reason
            self.body = http_resp.data
            self._parsed_exception = None
            normalized_headers = {k.lower(): v for k, v in headers}
            self.header = dict()
            for key in RESPONSE_HEADERS_TO_KEEP:
                self.header[key] = normalized_headers.get(key)
        else:
            self.status = status
            self.reason = reason
            self.body = None
            self._parsed_exception = None
            self.header = dict()

        self.operation_name = operation_name

    def __str__(self):
        parts = []

        if self.operation_name:
            parts.append(f"Operation: {self.operation_name}")

        parts.append(f"Status: {self.status}")

        if self.code:
            parts.append(f"Error Code: {self.code}")

        if self.error_message:
            parts.append(f"Message: {self.error_message}")
        elif self.reason:
            parts.append(f"Reason: {self.reason}")

        if self.request_id:
            parts.append(f"Request ID: {self.request_id}")

        if self.store_id:
            parts.append(f"Store ID: {self.store_id}")

        if self.authorization_model_id:
            parts.append(f"Authorization Model ID: {self.authorization_model_id}")

        if self.body:
            parts.append(f"HTTP response body: {self.body}")

        return "\n".join(parts)

    @property
    def parsed_exception(self):
        raise AttributeError(
            "parsed_exception is not directly accessible. "
            "Use e.code, e.error_message, e.request_id instead."
        )

    @parsed_exception.setter
    def parsed_exception(self, content):
        self._parsed_exception = content

    @property
    def code(self):
        if self._parsed_exception and hasattr(self._parsed_exception, "code"):
            return self._parsed_exception.code
        return None

    @property
    def error_message(self):
        if self._parsed_exception and hasattr(self._parsed_exception, "message"):
            return self._parsed_exception.message
        return None

    @property
    def request_id(self):
        return self.header.get(FGA_REQUEST_ID)

    @property
    def store_id(self):
        return self.header.get("store_id")

    @property
    def authorization_model_id(self):
        return self.header.get(OPENFGA_AUTHORIZATION_MODEL_ID)

    def is_validation_error(self):
        return isinstance(self, ValidationException) or (
            self.code and "validation" in str(self.code).lower()
        )

    def is_not_found_error(self):
        return isinstance(self, NotFoundException) or self.status == 404

    def is_authentication_error(self):
        return isinstance(self, (UnauthorizedException, AuthenticationError)) or self.status == 401

    def is_authorization_error(self):
        return isinstance(self, ForbiddenException) or self.status == 403

    def is_rate_limit_error(self):
        return isinstance(self, RateLimitExceededError) or self.status == 429

    def is_server_error(self):
        return isinstance(self, ServiceException) or (self.status and self.status >= 500)

    def is_retryable(self):
        return self.status in [429, 500, 502, 503, 504]


class NotFoundException(ApiException):
    def __init__(self, status=None, reason=None, http_resp=None, operation_name=None):
        super().__init__(status, reason, http_resp, operation_name)


class UnauthorizedException(ApiException):
    def __init__(self, status=None, reason=None, http_resp=None, operation_name=None):
        super().__init__(status, reason, http_resp, operation_name)


class ForbiddenException(ApiException):
    def __init__(self, status=None, reason=None, http_resp=None, operation_name=None):
        super().__init__(status, reason, http_resp, operation_name)


class ServiceException(ApiException):
    def __init__(self, status=None, reason=None, http_resp=None, operation_name=None):
        super().__init__(status, reason, http_resp, operation_name)


class ValidationException(ApiException):
    def __init__(self, status=None, reason=None, http_resp=None, operation_name=None):
        super().__init__(status, reason, http_resp, operation_name)


class AuthenticationError(ApiException):
    def __init__(self, status=None, reason=None, http_resp=None, operation_name=None):
        super().__init__(status, reason, http_resp, operation_name)


class RateLimitExceededError(ApiException):
    def __init__(self, status=None, reason=None, http_resp=None, operation_name=None):
        super().__init__(status, reason, http_resp, operation_name)


def render_path(path_to_item):
    """Returns a string representation of a path"""
    result = ""
    for pth in path_to_item:
        if isinstance(pth, int):
            result += f"[{pth}]"
        else:
            result += f"['{pth}']"
    return result
